<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Gator Tot's BS Game Lobby</title>
  <%- include('shared/head') %>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    
  </style>
</head>

<body>
  <div id="container">
    <%- include('shared/menu') %>
    <h1>
      Welcome, <%= username %>!
    </h1>

    <p>Game name: <%= game_name %></p>

    <div>
      <h2 id="playerCountHeader">Current Players <span id="currentPlayerCount"><%= players.length %></span>/<%= max_players %>:</h2>
      <ul id="playerListArea">
        <% players.forEach(function(player) { %>
        <li>
          <%= player.username %>
            <% if (player.user_id === game_room_host_user_id) { %> (Host) <% } %>
        </li>
        <% }); %>
      </ul>
    </div>

    <% if (user_id === game_room_host_user_id) { %>
      <button id="startGameButton" class="start-btn" <% if (players.length < min_players) { %>
        disabled
        title="Need at least <%= min_players %> players to start"
          <% } %>>
          Start Game
      </button>
    <% } else if (game_room_host_user_id) { %>
      <% const hostPlayer = players.find(p => p.user_id === game_room_host_user_id); %>
      <p id="waitingForHostMessage">Waiting for the host (<%= hostPlayer ? hostPlayer.username : 'Unknown' %>) to start the game...</p>
    <% } else { %>
      <p id="waitingForHostInfoMessage">Waiting for host information...</p>
    <% } %>

    <div id="gameArea">
        <h2>Game Started!</h2>
        <p>My Hand: <pre id="myHandArea">Waiting for cards...</pre></p>
        <p>Current Turn: <span id="currentPlayerTurnArea"></span></p>
        <p>Players in Game:</p>
        <ul id="gamePlayersList"></ul>
        <p>--- More game UI will go here ---</p>
    </div>

  </div>

  <div id="chat-window">
    <ul id="chat-messages"></ul>
    <form id="chat-form">
      <input type="text" id="chat-input" autocomplete="off" placeholder="Type a message..." />
      <button type="submit">Send</button>
    </form>
  </div>

  <input type="hidden" id="gameRoomIdInput" value="<%= gameId %>">
  <input type="hidden" id="isUserHostInput" value="<%= user_id === game_room_host_user_id %>">
  <input type="hidden" id="minPlayersInput" value="<%= min_players %>">
  <input type="hidden" id="gameRoomHostUserIdInput" value="<%= typeof game_room_host_user_id !== 'undefined' ? game_room_host_user_id : '' %>">
  <input type="hidden" id="currentUserIdInput" value="<%= user_id %>">
  <input type="hidden" id="maxPlayersInput" value="<%= max_players %>">


<script>
  // Client-side EJS-passed variables
  const gameId = document.getElementById("gameRoomIdInput").value;
  const isHost = document.getElementById("isUserHostInput").value === 'true';
  const minPlayers = parseInt(document.getElementById("minPlayersInput").value, 10);
  const gameRoomHostUserId = parseInt(document.getElementById("gameRoomHostUserIdInput").value, 10);
  const currentUserId = parseInt(document.getElementById("currentUserIdInput").value, 10);
  const maxPlayers = parseInt(document.getElementById("maxPlayersInput").value, 10);

  const socket = io(); // Initialize Socket.IO client

  // DOM element references
  const playerListUl = document.getElementById('playerListArea');
  const currentPlayerCountSpan = document.getElementById('currentPlayerCount');
  const playerCountHeader = document.getElementById('playerCountHeader');
  const startGameButton = document.getElementById('startGameButton');
  const gameAreaDiv = document.getElementById('gameArea');
  const myHandArea = document.getElementById('myHandArea');
  const currentPlayerTurnArea = document.getElementById('currentPlayerTurnArea');
  const gamePlayersListUl = document.getElementById('gamePlayersList');
  const chatMessagesUl = document.getElementById("chat-messages");
  const chatForm = document.getElementById("chat-form");
  const chatInput = document.getElementById("chat-input");
  const waitingForHostMessageP = document.getElementById("waitingForHostMessage");
  const waitingForHostInfoMessageP = document.getElementById("waitingForHostInfoMessage");

  // Chat: Listen for incoming messages
  if (chatMessagesUl) {
    socket.on(`chat:message:${gameId}`, function(data) {
      const li = document.createElement("li");
      li.textContent = `[${new Date(data.timestamp).toLocaleTimeString()}] ${data.sender.username}: ${data.message}`;
      chatMessagesUl.appendChild(li);
      chatMessagesUl.scrollTop = chatMessagesUl.scrollHeight;
    });
  }

  // Chat: Handle sending messages
  if (chatForm) {
    chatForm.addEventListener("submit", function(e) {
      e.preventDefault();
      if (chatInput && chatInput.value) {
        fetch(`/chat/${gameId}`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message: chatInput.value }),
        });
        chatInput.value = "";
      }
    });
  }

  // Chat: Load previous messages on page load
  if (chatMessagesUl) {
    fetch(`/chat/${gameId}/messages`)
      .then(res => res.json())
      .then(messages => {
        messages.forEach(msg => {
          const li = document.createElement("li");
          li.textContent = `[${new Date(msg.timestamp).toLocaleTimeString()}] ${msg.username}: ${msg.message_content}`;
          chatMessagesUl.appendChild(li);
        });
        chatMessagesUl.scrollTop = chatMessagesUl.scrollHeight;
      })
      .catch(err => console.error("Error fetching chat messages:", err));
  }

  // Lobby: Listen for updates (e.g., player join/leave)
  socket.on('lobby:updated', function(data) {
    if (data && data.gameId == parseInt(gameId, 10)) {
      // Update player list display
      if (playerListUl && data.players) {
        playerListUl.innerHTML = '';
        data.players.forEach(function(player) {
          const li = document.createElement('li');
          li.textContent = player.username;
          if (player.user_id === gameRoomHostUserId) {
              li.textContent += ' (Host)';
          }
          playerListUl.appendChild(li);
        });
      }
      // Update current player count display
      if (currentPlayerCountSpan && data.players) {
        currentPlayerCountSpan.textContent = data.players.length;
      }
      if (playerCountHeader && data.players && !isNaN(maxPlayers)) {
          playerCountHeader.textContent = `Current Players ${data.players.length}/${maxPlayers}:`;
      }

      // Update Start Game button state for host
      if (startGameButton && isHost) {
        if (data.players && data.players.length >= minPlayers) {
          startGameButton.disabled = false;
          startGameButton.title = "Start Game";
        } else {
          startGameButton.disabled = true;
          startGameButton.title = `Need at least ${minPlayers} players to start`;
        }
      }
    }
  });

  // Game Start: Handle host clicking "Start Game" button
  if (startGameButton && isHost) {
    startGameButton.addEventListener('click', async () => {
      startGameButton.disabled = true;
      startGameButton.textContent = "Starting...";
      try {
        const response = await fetch(`/games/${gameId}/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        const result = await response.json();
        if (!response.ok) {
          console.error('Game start request failed:', result);
          alert(`Error starting game: ${result.message || 'Server error.'}`);
          startGameButton.disabled = false; // Re-enable on failure
          startGameButton.textContent = "Start Game";
        }
        // Successful response means server will emit 'game:started'
      } catch (error) {
        console.error('Error sending start game request:', error);
        alert('Failed to send start game request. Check console.');
        startGameButton.disabled = false; // Re-enable on failure
        startGameButton.textContent = "Start Game";
      }
    });
  }

  // Game Logic: Listen for when the server confirms the game has started
  socket.on('game:started', (data) => {
    if (data && data.gameId == parseInt(gameId, 10)) {
      // Hide lobby UI elements
      if (startGameButton) startGameButton.style.display = 'none';
      if (playerCountHeader) playerCountHeader.style.display = 'none';
      if (playerListUl) playerListUl.style.display = 'none';
      if (waitingForHostMessageP) waitingForHostMessageP.style.display = 'none';
      if (waitingForHostInfoMessageP) waitingForHostInfoMessageP.style.display = 'none';

      // Show game area
      if (gameAreaDiv) gameAreaDiv.style.display = 'block';

      // Display player's hand
      if (myHandArea && data.yourHand) {
        myHandArea.textContent = ''; // Clear previous
        data.yourHand.forEach(card => { // Render each card (simple version)
          const cardDiv = document.createElement('div');
          cardDiv.textContent = `Card ID: ${card.id} (R: ${card.rank}, S: ${card.suit})`; // Placeholder display
          myHandArea.appendChild(cardDiv);
        });
      }

      // Display current turn
      let firstPlayerUsername = 'Unknown';
      if (data.players && !isNaN(data.currentPlayerTurn)) {
        const currentPlayer = data.players.find(p => p.userId === data.currentPlayerTurn);
        if (currentPlayer) firstPlayerUsername = currentPlayer.username;
      }
      if (currentPlayerTurnArea) currentPlayerTurnArea.textContent = firstPlayerUsername;

      // Display player list within the game area
      if (gamePlayersListUl && data.players) {
        gamePlayersListUl.innerHTML = '';
        data.players.forEach(player => {
          const li = document.createElement('li');
          li.textContent = `${player.username} (${player.cardCount} cards)`;
          gamePlayersListUl.appendChild(li);
        });
      }
      // Notify game start (e.g. update a status message, not using alert for better UX)
      console.log(`Game started! Turn: ${firstPlayerUsername}`);
    }
  });

  // Game Logic: Listen for general game state updates
  socket.on('game:stateUpdate', (data) => {
    if (data && data.gameId == parseInt(gameId, 10)) {
      // Update current turn display
      if (currentPlayerTurnArea && data.players && !isNaN(data.currentPlayerTurn)) {
        const currentPlayer = data.players.find(p => p.userId === data.currentPlayerTurn);
        if (currentPlayer) currentPlayerTurnArea.textContent = currentPlayer.username;
      }
      // Update player list (card counts) in game area
      if (gamePlayersListUl && data.players) {
        gamePlayersListUl.innerHTML = '';
        data.players.forEach(player => {
          const li = document.createElement('li');
          li.textContent = `${player.username} (${player.cardCount} cards)`;
          gamePlayersListUl.appendChild(li);
        });
      }
    }
  });

  // Game Logic: Listen for game-specific errors from server
  socket.on('game:error', (errorMessage) => {
    console.error('[CLIENT RECEIVED game:error]:', errorMessage);
    alert(`Game Error: ${errorMessage}`); // Or display in a less intrusive way
  });

  // Explicitly join Socket.IO room for this game
  socket.emit("joinRoom", gameId);
  console.log(`Client attempting to join Socket.IO room: ${gameId}`);

</script>

</html>